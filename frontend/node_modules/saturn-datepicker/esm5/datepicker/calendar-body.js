/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingReturn,uselessCode} checked by tsc
 */
/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, ViewEncapsulation, NgZone, } from '@angular/core';
import { take } from 'rxjs/operators';
/**
 * An internal class that represents the data corresponding to a single calendar cell.
 * \@docs-private
 */
var /**
 * An internal class that represents the data corresponding to a single calendar cell.
 * \@docs-private
 */
SatCalendarCell = /** @class */ (function () {
    function SatCalendarCell(value, displayValue, ariaLabel, enabled, cssClasses) {
        this.value = value;
        this.displayValue = displayValue;
        this.ariaLabel = ariaLabel;
        this.enabled = enabled;
        this.cssClasses = cssClasses;
    }
    return SatCalendarCell;
}());
/**
 * An internal class that represents the data corresponding to a single calendar cell.
 * \@docs-private
 */
export { SatCalendarCell };
if (false) {
    /** @type {?} */
    SatCalendarCell.prototype.value;
    /** @type {?} */
    SatCalendarCell.prototype.displayValue;
    /** @type {?} */
    SatCalendarCell.prototype.ariaLabel;
    /** @type {?} */
    SatCalendarCell.prototype.enabled;
    /** @type {?} */
    SatCalendarCell.prototype.cssClasses;
}
/**
 * An internal component used to display calendar data in a table.
 * \@docs-private
 */
var SatCalendarBody = /** @class */ (function () {
    function SatCalendarBody(_elementRef, _ngZone) {
        this._elementRef = _elementRef;
        this._ngZone = _ngZone;
        /**
         * Whether to use date range selection behaviour.
         */
        this.rangeMode = false;
        /**
         * The number of columns in the table.
         */
        this.numCols = 7;
        /**
         * The cell number of the active cell in the table.
         */
        this.activeCell = 0;
        /**
         * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be
         * maintained even as the table resizes.
         */
        this.cellAspectRatio = 1;
        /**
         * Emits when a new value is selected.
         */
        this.selectedValueChange = new EventEmitter();
    }
    /**
     * @param {?} cell
     * @return {?}
     */
    SatCalendarBody.prototype._cellClicked = /**
     * @param {?} cell
     * @return {?}
     */
    function (cell) {
        if (cell.enabled) {
            this.selectedValueChange.emit(cell.value);
        }
    };
    /**
     * @param {?} cell
     * @return {?}
     */
    SatCalendarBody.prototype._mouseOverCell = /**
     * @param {?} cell
     * @return {?}
     */
    function (cell) {
        this._cellOver = cell.value;
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    SatCalendarBody.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        /** @type {?} */
        var columnChanges = changes['numCols'];
        var _a = this, rows = _a.rows, numCols = _a.numCols;
        if (changes['rows'] || columnChanges) {
            this._firstRowOffset = rows && rows.length && rows[0].length ? numCols - rows[0].length : 0;
        }
        if (changes['cellAspectRatio'] || columnChanges || !this._cellPadding) {
            this._cellPadding = 50 * this.cellAspectRatio / numCols + "%";
        }
        if (columnChanges || !this._cellWidth) {
            this._cellWidth = 100 / numCols + "%";
        }
        if (changes.activeCell) {
            this._cellOver = this.activeCell + 1;
        }
    };
    /**
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    SatCalendarBody.prototype._isActiveCell = /**
     * @param {?} rowIndex
     * @param {?} colIndex
     * @return {?}
     */
    function (rowIndex, colIndex) {
        /** @type {?} */
        var cellNumber = rowIndex * this.numCols + colIndex;
        // Account for the fact that the first row may not have as many cells.
        if (rowIndex) {
            cellNumber -= this._firstRowOffset;
        }
        return cellNumber == this.activeCell;
    };
    /** Whenever to mark cell as semi-selected (inside dates interval). */
    /**
     * Whenever to mark cell as semi-selected (inside dates interval).
     * @param {?} date
     * @return {?}
     */
    SatCalendarBody.prototype._isSemiSelected = /**
     * Whenever to mark cell as semi-selected (inside dates interval).
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (!this.rangeMode) {
            return false;
        }
        if (this.rangeFull) {
            return true;
        }
        /** Do not mark start and end of interval. */
        if (date === this.begin || date === this.end) {
            return false;
        }
        if (this.begin && !this.end) {
            return date > this.begin;
        }
        if (this.end && !this.begin) {
            return date < this.end;
        }
        return date > (/** @type {?} */ (this.begin)) && date < (/** @type {?} */ (this.end));
    };
    /** Whenever to mark cell as semi-selected before the second date is selected (between the begin cell and the hovered cell). */
    /**
     * Whenever to mark cell as semi-selected before the second date is selected (between the begin cell and the hovered cell).
     * @param {?} date
     * @return {?}
     */
    SatCalendarBody.prototype._isBetweenOverAndBegin = /**
     * Whenever to mark cell as semi-selected before the second date is selected (between the begin cell and the hovered cell).
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (!this._cellOver || !this.rangeMode || !this.beginSelected) {
            return false;
        }
        if (this.isBeforeSelected && !this.begin) {
            return date > this._cellOver;
        }
        if (this._cellOver > this.begin) {
            return date > this.begin && date < this._cellOver;
        }
        if (this._cellOver < this.begin) {
            return date < this.begin && date > this._cellOver;
        }
        return false;
    };
    /** Whenever to mark cell as begin of the range. */
    /**
     * Whenever to mark cell as begin of the range.
     * @param {?} date
     * @return {?}
     */
    SatCalendarBody.prototype._isBegin = /**
     * Whenever to mark cell as begin of the range.
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (this.rangeMode && this.beginSelected && this._cellOver) {
            if (this.isBeforeSelected && !this.begin) {
                return this._cellOver === date;
            }
            else {
                return (this.begin === date && !(this._cellOver < this.begin)) ||
                    (this._cellOver === date && this._cellOver < this.begin);
            }
        }
        return this.begin === date;
    };
    /** Whenever to mark cell as end of the range. */
    /**
     * Whenever to mark cell as end of the range.
     * @param {?} date
     * @return {?}
     */
    SatCalendarBody.prototype._isEnd = /**
     * Whenever to mark cell as end of the range.
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (this.rangeMode && this.beginSelected && this._cellOver) {
            if (this.isBeforeSelected && !this.begin) {
                return false;
            }
            else {
                return (this.end === date && !(this._cellOver > this.begin)) ||
                    (this._cellOver === date && this._cellOver > this.begin);
            }
        }
        return this.end === date;
    };
    /** Focuses the active cell after the microtask queue is empty. */
    /**
     * Focuses the active cell after the microtask queue is empty.
     * @return {?}
     */
    SatCalendarBody.prototype._focusActiveCell = /**
     * Focuses the active cell after the microtask queue is empty.
     * @return {?}
     */
    function () {
        var _this = this;
        this._ngZone.runOutsideAngular(function () {
            _this._ngZone.onStable.asObservable().pipe(take(1)).subscribe(function () {
                /** @type {?} */
                var activeCell = _this._elementRef.nativeElement.querySelector('.mat-calendar-body-active');
                if (activeCell) {
                    activeCell.focus();
                }
            });
        });
    };
    /** Whenever to highlight the target cell when selecting the second date in range mode */
    /**
     * Whenever to highlight the target cell when selecting the second date in range mode
     * @param {?} date
     * @return {?}
     */
    SatCalendarBody.prototype._previewCellOver = /**
     * Whenever to highlight the target cell when selecting the second date in range mode
     * @param {?} date
     * @return {?}
     */
    function (date) {
        return this._cellOver === date && this.rangeMode && this.beginSelected;
    };
    SatCalendarBody.decorators = [
        { type: Component, args: [{
                    moduleId: module.id,
                    selector: '[sat-calendar-body]',
                    template: "<!--\n  If there's not enough space in the first row, create a separate label row. We mark this row as\n  aria-hidden because we don't want it to be read out as one of the weeks in the month.\n-->\n<tr *ngIf=\"_firstRowOffset < labelMinRequiredCells\" aria-hidden=\"true\">\n  <td class=\"mat-calendar-body-label\"\n      [attr.colspan]=\"numCols\"\n      [style.paddingTop]=\"_cellPadding\"\n      [style.paddingBottom]=\"_cellPadding\">\n    {{label}}\n  </td>\n</tr>\n\n<!-- Create the first row separately so we can include a special spacer cell. -->\n<tr *ngFor=\"let row of rows; let rowIndex = index\" role=\"row\">\n  <!--\n    We mark this cell as aria-hidden so it doesn't get read out as one of the days in the week.\n    The aspect ratio of the table cells is maintained by setting the top and bottom padding as a\n    percentage of the width (a variant of the trick described here:\n    https://www.w3schools.com/howto/howto_css_aspect_ratio.asp).\n  -->\n  <td *ngIf=\"rowIndex === 0 && _firstRowOffset\"\n      aria-hidden=\"true\"\n      class=\"mat-calendar-body-label\"\n      [attr.colspan]=\"_firstRowOffset\"\n      [style.paddingTop]=\"_cellPadding\"\n      [style.paddingBottom]=\"_cellPadding\">\n    {{_firstRowOffset >= labelMinRequiredCells ? label : ''}}\n  </td>\n  <td *ngFor=\"let item of row; let colIndex = index\"\n      role=\"gridcell\"\n      class=\"mat-calendar-body-cell\"\n      [ngClass]=\"item.cssClasses\"\n      [tabindex]=\"_isActiveCell(rowIndex, colIndex) ? 0 : -1\"\n      [class.mat-calendar-body-disabled]=\"!item.enabled\"\n      [class.mat-calendar-body-active]=\"_isActiveCell(rowIndex, colIndex)\"\n      [class.mat-calendar-body-begin-range]=\"_isBegin(item.value)\"\n      [class.mat-calendar-body-end-range]=\"_isEnd(item.value)\"\n      [class.mat-calendar-cell-semi-selected]=\"_isSemiSelected(item.value) || _isBetweenOverAndBegin(item.value)\"\n      [class.mat-calendar-cell-over]=\"_previewCellOver(item.value)\"\n      [attr.aria-label]=\"item.ariaLabel\"\n      [attr.aria-disabled]=\"!item.enabled || null\"\n      [attr.aria-selected]=\"selectedValue === item.value\"\n      (click)=\"_cellClicked(item)\"\n      (mouseover)=\"_mouseOverCell(item)\"\n      [style.width]=\"_cellWidth\"\n      [style.paddingTop]=\"_cellPadding\"\n      [style.paddingBottom]=\"_cellPadding\">\n    <div class=\"mat-calendar-body-cell-content\"\n         [class.mat-calendar-body-selected]=\"begin === item.value || end === item.value || selectedValue === item.value\"\n         [class.mat-calendar-body-semi-selected]=\"_isSemiSelected(item.value)\"\n         [class.mat-calendar-body-today]=\"todayValue === item.value\">\n      {{item.displayValue}}\n    </div>\n  </td>\n</tr>\n",
                    host: {
                        'class': 'mat-calendar-body',
                        'role': 'grid',
                        'aria-readonly': 'true'
                    },
                    exportAs: 'matCalendarBody',
                    encapsulation: ViewEncapsulation.None,
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    styles: [".mat-calendar-body{min-width:224px}.mat-calendar-body-label{height:0;line-height:0;text-align:left;padding-left:4.71429%;padding-right:4.71429%}.mat-calendar-body-cell{position:relative;height:0;line-height:0;text-align:center;outline:0;cursor:pointer}.mat-calendar-body-disabled{cursor:default}.mat-calendar-body-cell-content{position:absolute;top:5%;left:5%;display:flex;align-items:center;justify-content:center;box-sizing:border-box;width:90%;height:90%;line-height:1;border-width:1px;border-style:solid;border-radius:999px}[dir=rtl] .mat-calendar-body-label{text-align:right}"]
                }] }
    ];
    /** @nocollapse */
    SatCalendarBody.ctorParameters = function () { return [
        { type: ElementRef },
        { type: NgZone }
    ]; };
    SatCalendarBody.propDecorators = {
        label: [{ type: Input }],
        rows: [{ type: Input }],
        todayValue: [{ type: Input }],
        selectedValue: [{ type: Input }],
        begin: [{ type: Input }],
        end: [{ type: Input }],
        beginSelected: [{ type: Input }],
        isBeforeSelected: [{ type: Input }],
        rangeFull: [{ type: Input }],
        rangeMode: [{ type: Input }],
        labelMinRequiredCells: [{ type: Input }],
        numCols: [{ type: Input }],
        activeCell: [{ type: Input }],
        cellAspectRatio: [{ type: Input }],
        selectedValueChange: [{ type: Output }]
    };
    return SatCalendarBody;
}());
export { SatCalendarBody };
if (false) {
    /**
     * The label for the table. (e.g. "Jan 2017").
     * @type {?}
     */
    SatCalendarBody.prototype.label;
    /**
     * The cells to display in the table.
     * @type {?}
     */
    SatCalendarBody.prototype.rows;
    /**
     * The value in the table that corresponds to today.
     * @type {?}
     */
    SatCalendarBody.prototype.todayValue;
    /**
     * The value in the table that is currently selected.
     * @type {?}
     */
    SatCalendarBody.prototype.selectedValue;
    /**
     * The value in the table since range of dates started.
     * Null means no interval or interval doesn't start in this month
     * @type {?}
     */
    SatCalendarBody.prototype.begin;
    /**
     * The value in the table representing end of dates range.
     * Null means no interval or interval doesn't end in this month
     * @type {?}
     */
    SatCalendarBody.prototype.end;
    /**
     * Whenever user already selected start of dates interval.
     * @type {?}
     */
    SatCalendarBody.prototype.beginSelected;
    /**
     * Whenever the current month is before the date already selected
     * @type {?}
     */
    SatCalendarBody.prototype.isBeforeSelected;
    /**
     * Whether to mark all dates as semi-selected.
     * @type {?}
     */
    SatCalendarBody.prototype.rangeFull;
    /**
     * Whether to use date range selection behaviour.
     * @type {?}
     */
    SatCalendarBody.prototype.rangeMode;
    /**
     * The minimum number of free cells needed to fit the label in the first row.
     * @type {?}
     */
    SatCalendarBody.prototype.labelMinRequiredCells;
    /**
     * The number of columns in the table.
     * @type {?}
     */
    SatCalendarBody.prototype.numCols;
    /**
     * The cell number of the active cell in the table.
     * @type {?}
     */
    SatCalendarBody.prototype.activeCell;
    /**
     * The aspect ratio (width / height) to use for the cells in the table. This aspect ratio will be
     * maintained even as the table resizes.
     * @type {?}
     */
    SatCalendarBody.prototype.cellAspectRatio;
    /**
     * Emits when a new value is selected.
     * @type {?}
     */
    SatCalendarBody.prototype.selectedValueChange;
    /**
     * The number of blank cells to put at the beginning for the first row.
     * @type {?}
     */
    SatCalendarBody.prototype._firstRowOffset;
    /**
     * Padding for the individual date cells.
     * @type {?}
     */
    SatCalendarBody.prototype._cellPadding;
    /**
     * Width of an individual cell.
     * @type {?}
     */
    SatCalendarBody.prototype._cellWidth;
    /**
     * The cell number of the hovered cell
     * @type {?}
     */
    SatCalendarBody.prototype._cellOver;
    /** @type {?} */
    SatCalendarBody.prototype._elementRef;
    /** @type {?} */
    SatCalendarBody.prototype._ngZone;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2FsZW5kYXItYm9keS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL3NhdHVybi1kYXRlcGlja2VyLyIsInNvdXJjZXMiOlsiZGF0ZXBpY2tlci9jYWxlbmRhci1ib2R5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBUUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixTQUFTLEVBQ1QsVUFBVSxFQUNWLFlBQVksRUFDWixLQUFLLEVBQ0wsTUFBTSxFQUNOLGlCQUFpQixFQUNqQixNQUFNLEdBR1AsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFDLElBQUksRUFBQyxNQUFNLGdCQUFnQixDQUFDOzs7OztBQVdwQzs7Ozs7SUFDRSx5QkFBbUIsS0FBYSxFQUNiLFlBQW9CLEVBQ3BCLFNBQWlCLEVBQ2pCLE9BQWdCLEVBQ2hCLFVBQXNDO1FBSnRDLFVBQUssR0FBTCxLQUFLLENBQVE7UUFDYixpQkFBWSxHQUFaLFlBQVksQ0FBUTtRQUNwQixjQUFTLEdBQVQsU0FBUyxDQUFRO1FBQ2pCLFlBQU8sR0FBUCxPQUFPLENBQVM7UUFDaEIsZUFBVSxHQUFWLFVBQVUsQ0FBNEI7SUFBRyxDQUFDO0lBQy9ELHNCQUFDO0FBQUQsQ0FBQyxBQU5ELElBTUM7Ozs7Ozs7O0lBTGEsZ0NBQW9COztJQUNwQix1Q0FBMkI7O0lBQzNCLG9DQUF3Qjs7SUFDeEIsa0NBQXVCOztJQUN2QixxQ0FBNkM7Ozs7OztBQVEzRDtJQStFRSx5QkFBb0IsV0FBb0MsRUFBVSxPQUFlO1FBQTdELGdCQUFXLEdBQVgsV0FBVyxDQUF5QjtRQUFVLFlBQU8sR0FBUCxPQUFPLENBQVE7Ozs7UUFoQ3hFLGNBQVMsR0FBRyxLQUFLLENBQUM7Ozs7UUFNbEIsWUFBTyxHQUFHLENBQUMsQ0FBQzs7OztRQUdaLGVBQVUsR0FBRyxDQUFDLENBQUM7Ozs7O1FBTWYsb0JBQWUsR0FBRyxDQUFDLENBQUM7Ozs7UUFHVix3QkFBbUIsR0FBeUIsSUFBSSxZQUFZLEVBQVUsQ0FBQztJQWNMLENBQUM7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OztJQUcxRiwwQ0FBd0I7Ozs7O0lBR3hCLHVDQUFxQjs7Ozs7SUFHckIscUNBQW1COzs7OztJQUduQixvQ0FBa0I7O0lBRU4sc0NBQTRDOztJQUFFLGtDQUF1QiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuXG5pbXBvcnQge1xuICBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneSxcbiAgQ29tcG9uZW50LFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIElucHV0LFxuICBPdXRwdXQsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBOZ1pvbmUsXG4gIE9uQ2hhbmdlcyxcbiAgU2ltcGxlQ2hhbmdlcyxcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge3Rha2V9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuLyoqXG4gKiBFeHRyYSBDU1MgY2xhc3NlcyB0aGF0IGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggYSBjYWxlbmRhciBjZWxsLlxuICovXG5leHBvcnQgdHlwZSBTYXRDYWxlbmRhckNlbGxDc3NDbGFzc2VzID0gc3RyaW5nIHwgc3RyaW5nW10gfCBTZXQ8c3RyaW5nPiB8IHtba2V5OiBzdHJpbmddOiBhbnl9O1xuXG4vKipcbiAqIEFuIGludGVybmFsIGNsYXNzIHRoYXQgcmVwcmVzZW50cyB0aGUgZGF0YSBjb3JyZXNwb25kaW5nIHRvIGEgc2luZ2xlIGNhbGVuZGFyIGNlbGwuXG4gKiBAZG9jcy1wcml2YXRlXG4gKi9cbmV4cG9ydCBjbGFzcyBTYXRDYWxlbmRhckNlbGwge1xuICBjb25zdHJ1Y3RvcihwdWJsaWMgdmFsdWU6IG51bWJlcixcbiAgICAgICAgICAgICAgcHVibGljIGRpc3BsYXlWYWx1ZTogc3RyaW5nLFxuICAgICAgICAgICAgICBwdWJsaWMgYXJpYUxhYmVsOiBzdHJpbmcsXG4gICAgICAgICAgICAgIHB1YmxpYyBlbmFibGVkOiBib29sZWFuLFxuICAgICAgICAgICAgICBwdWJsaWMgY3NzQ2xhc3Nlcz86IFNhdENhbGVuZGFyQ2VsbENzc0NsYXNzZXMpIHt9XG59XG5cblxuLyoqXG4gKiBBbiBpbnRlcm5hbCBjb21wb25lbnQgdXNlZCB0byBkaXNwbGF5IGNhbGVuZGFyIGRhdGEgaW4gYSB0YWJsZS5cbiAqIEBkb2NzLXByaXZhdGVcbiAqL1xuQENvbXBvbmVudCh7XG4gIG1vZHVsZUlkOiBtb2R1bGUuaWQsXG4gIHNlbGVjdG9yOiAnW3NhdC1jYWxlbmRhci1ib2R5XScsXG4gIHRlbXBsYXRlVXJsOiAnY2FsZW5kYXItYm9keS5odG1sJyxcbiAgc3R5bGVVcmxzOiBbJ2NhbGVuZGFyLWJvZHkuY3NzJ10sXG4gIGhvc3Q6IHtcbiAgICAnY2xhc3MnOiAnbWF0LWNhbGVuZGFyLWJvZHknLFxuICAgICdyb2xlJzogJ2dyaWQnLFxuICAgICdhcmlhLXJlYWRvbmx5JzogJ3RydWUnXG4gIH0sXG4gIGV4cG9ydEFzOiAnbWF0Q2FsZW5kYXJCb2R5JyxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG59KVxuZXhwb3J0IGNsYXNzIFNhdENhbGVuZGFyQm9keSBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG4gIC8qKiBUaGUgbGFiZWwgZm9yIHRoZSB0YWJsZS4gKGUuZy4gXCJKYW4gMjAxN1wiKS4gKi9cbiAgQElucHV0KCkgbGFiZWw6IHN0cmluZztcblxuICAvKiogVGhlIGNlbGxzIHRvIGRpc3BsYXkgaW4gdGhlIHRhYmxlLiAqL1xuICBASW5wdXQoKSByb3dzOiBTYXRDYWxlbmRhckNlbGxbXVtdO1xuXG4gIC8qKiBUaGUgdmFsdWUgaW4gdGhlIHRhYmxlIHRoYXQgY29ycmVzcG9uZHMgdG8gdG9kYXkuICovXG4gIEBJbnB1dCgpIHRvZGF5VmFsdWU6IG51bWJlcjtcblxuICAvKiogVGhlIHZhbHVlIGluIHRoZSB0YWJsZSB0aGF0IGlzIGN1cnJlbnRseSBzZWxlY3RlZC4gKi9cbiAgQElucHV0KCkgc2VsZWN0ZWRWYWx1ZTogbnVtYmVyO1xuXG4gIC8qKiBUaGUgdmFsdWUgaW4gdGhlIHRhYmxlIHNpbmNlIHJhbmdlIG9mIGRhdGVzIHN0YXJ0ZWQuXG4gICAqIE51bGwgbWVhbnMgbm8gaW50ZXJ2YWwgb3IgaW50ZXJ2YWwgZG9lc24ndCBzdGFydCBpbiB0aGlzIG1vbnRoXG4gICAqL1xuICBASW5wdXQoKSBiZWdpbjogbnVtYmVyfG51bGw7XG5cbiAgLyoqIFRoZSB2YWx1ZSBpbiB0aGUgdGFibGUgcmVwcmVzZW50aW5nIGVuZCBvZiBkYXRlcyByYW5nZS5cbiAgICogTnVsbCBtZWFucyBubyBpbnRlcnZhbCBvciBpbnRlcnZhbCBkb2Vzbid0IGVuZCBpbiB0aGlzIG1vbnRoXG4gICAqL1xuICBASW5wdXQoKSBlbmQ6IG51bWJlcnxudWxsO1xuXG4gIC8qKiBXaGVuZXZlciB1c2VyIGFscmVhZHkgc2VsZWN0ZWQgc3RhcnQgb2YgZGF0ZXMgaW50ZXJ2YWwuICovXG4gIEBJbnB1dCgpIGJlZ2luU2VsZWN0ZWQ6IGJvb2xlYW47XG5cbiAgLyoqIFdoZW5ldmVyIHRoZSBjdXJyZW50IG1vbnRoIGlzIGJlZm9yZSB0aGUgZGF0ZSBhbHJlYWR5IHNlbGVjdGVkICovXG4gIEBJbnB1dCgpIGlzQmVmb3JlU2VsZWN0ZWQ6IGJvb2xlYW47XG5cbiAgLyoqIFdoZXRoZXIgdG8gbWFyayBhbGwgZGF0ZXMgYXMgc2VtaS1zZWxlY3RlZC4gKi9cbiAgQElucHV0KCkgcmFuZ2VGdWxsOiBib29sZWFuO1xuXG4gIC8qKiBXaGV0aGVyIHRvIHVzZSBkYXRlIHJhbmdlIHNlbGVjdGlvbiBiZWhhdmlvdXIuKi9cbiAgQElucHV0KCkgcmFuZ2VNb2RlID0gZmFsc2U7XG5cbiAgLyoqIFRoZSBtaW5pbXVtIG51bWJlciBvZiBmcmVlIGNlbGxzIG5lZWRlZCB0byBmaXQgdGhlIGxhYmVsIGluIHRoZSBmaXJzdCByb3cuICovXG4gIEBJbnB1dCgpIGxhYmVsTWluUmVxdWlyZWRDZWxsczogbnVtYmVyO1xuXG4gIC8qKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgaW4gdGhlIHRhYmxlLiAqL1xuICBASW5wdXQoKSBudW1Db2xzID0gNztcblxuICAvKiogVGhlIGNlbGwgbnVtYmVyIG9mIHRoZSBhY3RpdmUgY2VsbCBpbiB0aGUgdGFibGUuICovXG4gIEBJbnB1dCgpIGFjdGl2ZUNlbGwgPSAwO1xuXG4gIC8qKlxuICAgKiBUaGUgYXNwZWN0IHJhdGlvICh3aWR0aCAvIGhlaWdodCkgdG8gdXNlIGZvciB0aGUgY2VsbHMgaW4gdGhlIHRhYmxlLiBUaGlzIGFzcGVjdCByYXRpbyB3aWxsIGJlXG4gICAqIG1haW50YWluZWQgZXZlbiBhcyB0aGUgdGFibGUgcmVzaXplcy5cbiAgICovXG4gIEBJbnB1dCgpIGNlbGxBc3BlY3RSYXRpbyA9IDE7XG5cbiAgLyoqIEVtaXRzIHdoZW4gYSBuZXcgdmFsdWUgaXMgc2VsZWN0ZWQuICovXG4gIEBPdXRwdXQoKSByZWFkb25seSBzZWxlY3RlZFZhbHVlQ2hhbmdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIC8qKiBUaGUgbnVtYmVyIG9mIGJsYW5rIGNlbGxzIHRvIHB1dCBhdCB0aGUgYmVnaW5uaW5nIGZvciB0aGUgZmlyc3Qgcm93LiAqL1xuICBfZmlyc3RSb3dPZmZzZXQ6IG51bWJlcjtcblxuICAvKiogUGFkZGluZyBmb3IgdGhlIGluZGl2aWR1YWwgZGF0ZSBjZWxscy4gKi9cbiAgX2NlbGxQYWRkaW5nOiBzdHJpbmc7XG5cbiAgLyoqIFdpZHRoIG9mIGFuIGluZGl2aWR1YWwgY2VsbC4gKi9cbiAgX2NlbGxXaWR0aDogc3RyaW5nO1xuXG4gIC8qKiBUaGUgY2VsbCBudW1iZXIgb2YgdGhlIGhvdmVyZWQgY2VsbCAqL1xuICBfY2VsbE92ZXI6IG51bWJlcjtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmPEhUTUxFbGVtZW50PiwgcHJpdmF0ZSBfbmdab25lOiBOZ1pvbmUpIHsgfVxuXG4gIF9jZWxsQ2xpY2tlZChjZWxsOiBTYXRDYWxlbmRhckNlbGwpOiB2b2lkIHtcbiAgICBpZiAoY2VsbC5lbmFibGVkKSB7XG4gICAgICB0aGlzLnNlbGVjdGVkVmFsdWVDaGFuZ2UuZW1pdChjZWxsLnZhbHVlKTtcbiAgICB9XG4gIH1cblxuICBfbW91c2VPdmVyQ2VsbChjZWxsOiBTYXRDYWxlbmRhckNlbGwpOiB2b2lkIHtcbiAgICB0aGlzLl9jZWxsT3ZlciA9IGNlbGwudmFsdWU7XG4gIH1cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgY29uc3QgY29sdW1uQ2hhbmdlcyA9IGNoYW5nZXNbJ251bUNvbHMnXTtcbiAgICBjb25zdCB7cm93cywgbnVtQ29sc30gPSB0aGlzO1xuXG4gICAgaWYgKGNoYW5nZXNbJ3Jvd3MnXSB8fCBjb2x1bW5DaGFuZ2VzKSB7XG4gICAgICB0aGlzLl9maXJzdFJvd09mZnNldCA9IHJvd3MgJiYgcm93cy5sZW5ndGggJiYgcm93c1swXS5sZW5ndGggPyBudW1Db2xzIC0gcm93c1swXS5sZW5ndGggOiAwO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzWydjZWxsQXNwZWN0UmF0aW8nXSB8fCBjb2x1bW5DaGFuZ2VzIHx8ICF0aGlzLl9jZWxsUGFkZGluZykge1xuICAgICAgdGhpcy5fY2VsbFBhZGRpbmcgPSBgJHs1MCAqIHRoaXMuY2VsbEFzcGVjdFJhdGlvIC8gbnVtQ29sc30lYDtcbiAgICB9XG5cbiAgICBpZiAoY29sdW1uQ2hhbmdlcyB8fCAhdGhpcy5fY2VsbFdpZHRoKSB7XG4gICAgICB0aGlzLl9jZWxsV2lkdGggPSBgJHsxMDAgLyBudW1Db2xzfSVgO1xuICAgIH1cblxuICAgIGlmIChjaGFuZ2VzLmFjdGl2ZUNlbGwpIHtcbiAgICAgIHRoaXMuX2NlbGxPdmVyID0gdGhpcy5hY3RpdmVDZWxsICsgMTtcbiAgICB9XG4gIH1cblxuICBfaXNBY3RpdmVDZWxsKHJvd0luZGV4OiBudW1iZXIsIGNvbEluZGV4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgICBsZXQgY2VsbE51bWJlciA9IHJvd0luZGV4ICogdGhpcy5udW1Db2xzICsgY29sSW5kZXg7XG5cbiAgICAvLyBBY2NvdW50IGZvciB0aGUgZmFjdCB0aGF0IHRoZSBmaXJzdCByb3cgbWF5IG5vdCBoYXZlIGFzIG1hbnkgY2VsbHMuXG4gICAgaWYgKHJvd0luZGV4KSB7XG4gICAgICBjZWxsTnVtYmVyIC09IHRoaXMuX2ZpcnN0Um93T2Zmc2V0O1xuICAgIH1cblxuICAgIHJldHVybiBjZWxsTnVtYmVyID09IHRoaXMuYWN0aXZlQ2VsbDtcbiAgfVxuXG4gIC8qKiBXaGVuZXZlciB0byBtYXJrIGNlbGwgYXMgc2VtaS1zZWxlY3RlZCAoaW5zaWRlIGRhdGVzIGludGVydmFsKS4gKi9cbiAgX2lzU2VtaVNlbGVjdGVkKGRhdGU6IG51bWJlcikge1xuICAgIGlmICghdGhpcy5yYW5nZU1vZGUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmFuZ2VGdWxsKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqIERvIG5vdCBtYXJrIHN0YXJ0IGFuZCBlbmQgb2YgaW50ZXJ2YWwuICovXG4gICAgaWYgKGRhdGUgPT09IHRoaXMuYmVnaW4gfHwgZGF0ZSA9PT0gdGhpcy5lbmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmVnaW4gJiYgIXRoaXMuZW5kKSB7XG4gICAgICByZXR1cm4gZGF0ZSA+IHRoaXMuYmVnaW47XG4gICAgfVxuICAgIGlmICh0aGlzLmVuZCAmJiAhdGhpcy5iZWdpbikge1xuICAgICAgcmV0dXJuIGRhdGUgPCB0aGlzLmVuZDtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGUgPiA8bnVtYmVyPnRoaXMuYmVnaW4gJiYgZGF0ZSA8IDxudW1iZXI+dGhpcy5lbmQ7XG4gIH1cblxuICAvKiogV2hlbmV2ZXIgdG8gbWFyayBjZWxsIGFzIHNlbWktc2VsZWN0ZWQgYmVmb3JlIHRoZSBzZWNvbmQgZGF0ZSBpcyBzZWxlY3RlZCAoYmV0d2VlbiB0aGUgYmVnaW4gY2VsbCBhbmQgdGhlIGhvdmVyZWQgY2VsbCkuICovXG4gIF9pc0JldHdlZW5PdmVyQW5kQmVnaW4oZGF0ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKCF0aGlzLl9jZWxsT3ZlciB8fCAhdGhpcy5yYW5nZU1vZGUgfHwgIXRoaXMuYmVnaW5TZWxlY3RlZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0JlZm9yZVNlbGVjdGVkICYmICF0aGlzLmJlZ2luKSB7XG4gICAgICByZXR1cm4gZGF0ZSA+IHRoaXMuX2NlbGxPdmVyO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2VsbE92ZXIgPiB0aGlzLmJlZ2luKSB7XG4gICAgICByZXR1cm4gZGF0ZSA+IHRoaXMuYmVnaW4gJiYgZGF0ZSA8IHRoaXMuX2NlbGxPdmVyO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2VsbE92ZXIgPCB0aGlzLmJlZ2luKSB7XG4gICAgICByZXR1cm4gZGF0ZSA8IHRoaXMuYmVnaW4gJiYgZGF0ZSA+IHRoaXMuX2NlbGxPdmVyO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvKiogV2hlbmV2ZXIgdG8gbWFyayBjZWxsIGFzIGJlZ2luIG9mIHRoZSByYW5nZS4gKi9cbiAgX2lzQmVnaW4oZGF0ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMucmFuZ2VNb2RlICYmIHRoaXMuYmVnaW5TZWxlY3RlZCAmJiB0aGlzLl9jZWxsT3Zlcikge1xuICAgICAgaWYgKHRoaXMuaXNCZWZvcmVTZWxlY3RlZCAmJiAhdGhpcy5iZWdpbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2VsbE92ZXIgPT09IGRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKHRoaXMuYmVnaW4gPT09IGRhdGUgJiYgISh0aGlzLl9jZWxsT3ZlciA8IHRoaXMuYmVnaW4pKSB8fFxuICAgICAgICAgICh0aGlzLl9jZWxsT3ZlciA9PT0gZGF0ZSAmJiB0aGlzLl9jZWxsT3ZlciA8IHRoaXMuYmVnaW4pXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJlZ2luID09PSBkYXRlO1xuICB9XG5cbiAgLyoqIFdoZW5ldmVyIHRvIG1hcmsgY2VsbCBhcyBlbmQgb2YgdGhlIHJhbmdlLiAqL1xuICBfaXNFbmQoZGF0ZTogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMucmFuZ2VNb2RlICYmIHRoaXMuYmVnaW5TZWxlY3RlZCAmJiB0aGlzLl9jZWxsT3Zlcikge1xuICAgICAgaWYgKHRoaXMuaXNCZWZvcmVTZWxlY3RlZCAmJiAhdGhpcy5iZWdpbikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gKHRoaXMuZW5kID09PSBkYXRlICYmICEodGhpcy5fY2VsbE92ZXIgPiB0aGlzLmJlZ2luKSkgfHxcbiAgICAgICAgICAodGhpcy5fY2VsbE92ZXIgPT09IGRhdGUgJiYgdGhpcy5fY2VsbE92ZXIgPiB0aGlzLmJlZ2luKVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5lbmQgPT09IGRhdGU7XG4gIH1cblxuICAvKiogRm9jdXNlcyB0aGUgYWN0aXZlIGNlbGwgYWZ0ZXIgdGhlIG1pY3JvdGFzayBxdWV1ZSBpcyBlbXB0eS4gKi9cbiAgX2ZvY3VzQWN0aXZlQ2VsbCgpIHtcbiAgICB0aGlzLl9uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgdGhpcy5fbmdab25lLm9uU3RhYmxlLmFzT2JzZXJ2YWJsZSgpLnBpcGUodGFrZSgxKSkuc3Vic2NyaWJlKCgpID0+IHtcbiAgICAgICAgY29uc3QgYWN0aXZlQ2VsbDogSFRNTEVsZW1lbnQgfCBudWxsID1cbiAgICAgICAgICAgIHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yKCcubWF0LWNhbGVuZGFyLWJvZHktYWN0aXZlJyk7XG5cbiAgICAgICAgaWYgKGFjdGl2ZUNlbGwpIHtcbiAgICAgICAgICBhY3RpdmVDZWxsLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFdoZW5ldmVyIHRvIGhpZ2hsaWdodCB0aGUgdGFyZ2V0IGNlbGwgd2hlbiBzZWxlY3RpbmcgdGhlIHNlY29uZCBkYXRlIGluIHJhbmdlIG1vZGUgKi9cbiAgX3ByZXZpZXdDZWxsT3ZlcihkYXRlOiBudW1iZXIpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fY2VsbE92ZXIgPT09IGRhdGUgJiYgdGhpcy5yYW5nZU1vZGUgJiYgdGhpcy5iZWdpblNlbGVjdGVkO1xuICB9XG59XG4iXX0=